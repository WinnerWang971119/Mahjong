# Phase 2.5 — UI Enhancement & Bug Fix Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix bugs, add interaction feedback, and polish the UI to make the game feel responsive and premium.

**Architecture:** Sequential approach — fix bugs first (replay viewer, discard flash, animations), then add interaction feedback (hover/click/turn indicators), then visual polish (table, tiles, lobby, typography). All changes are CSS/Tailwind + React component updates. One backend fix for replay frames.

**Tech Stack:** React 18, TypeScript, Tailwind CSS 4, Framer Motion, Zustand, FastAPI (backend replay fix)

---

## Group 1: Bug Fixes

### Task 1: Fix Replay Viewer — Frontend Frame Parsing

The ReplayViewer tries to `JSON.parse(frame.action_json)` and then reads `frame.state`, but the replay frames from the database already have the state embedded in the `action_json` field. The `action_json` contains `{"turn", "event", "player", "tile", "state": {...}}` — the backend already serializes state snapshots (see `game_manager.py:164-173`). The issue is that `ReplayViewer.applyFrame()` parses `action_json` correctly but the data flow from WebSocket → store may lose the structure.

**Files:**
- Modify: `frontend/src/components/replay/ReplayViewer.tsx`
- Modify: `frontend/src/types/game.ts` (ReplayFrame interface)

**Step 1: Update the ReplayFrame type to include parsed state**

In `frontend/src/types/game.ts`, the `ReplayFrame` interface currently models the database row shape (`action_json` as string). The WebSocket handler in `ws_server.py:205-210` sends raw DB rows. The `applyFrame` function in ReplayViewer parses `action_json` — this is correct but we need to verify the data flow works end-to-end.

Update `ReplayViewer.tsx` `applyFrame` to be more robust:

```tsx
const applyFrame = useCallback((index: number) => {
  if (!replayFrames || index >= replayFrames.length) return
  try {
    const frame = replayFrames[index]
    const data = typeof frame.action_json === 'string'
      ? JSON.parse(frame.action_json)
      : frame.action_json
    if (data.state) {
      setGameState(data.state)
    }
  } catch {
    // Skip malformed frames
  }
}, [replayFrames, setGameState])
```

Also apply the first frame on mount so the viewer isn't blank initially.

**Step 2: Load first frame on mount**

Add a `useEffect` in ReplayViewer that calls `applyFrame(0)` when `replayFrames` first becomes available.

**Step 3: Test manually**

Run: Start the app, play a full game, go to History, load a replay. Verify frames display and stepping works.

**Step 4: Commit**

```bash
git add frontend/src/components/replay/ReplayViewer.tsx
git commit -m "fix: make replay viewer parse frames robustly and load first frame on mount"
```

---

### Task 2: Fix Discard Flash Bug

**Problem:** When events arrive via WebSocket, the `useGameSocket` handler processes `event` messages. During normal play, AI discard/draw events fire rapidly. The handler at line 39-48 checks `msg.event === 'win' || msg.event === 'draw'` — but `'draw'` is ambiguous: it means both "draw a tile" (during play) and "draw game" (game over with no winner). When an AI draws a tile, the event is `"draw"` and the handler briefly transitions to scoring screen.

**Files:**
- Modify: `frontend/src/hooks/useGameSocket.ts`
- Modify: `backend/server/ws_server.py` (use distinct event name)
- Modify: `backend/server/game_manager.py` (use distinct event name)

**Step 1: Distinguish "draw tile" from "draw game" on the backend**

In `ws_server.py:273`, the game-end event already uses `phase` value which is `"draw"` for a drawn game. The problem is that `game_manager.py:_append_event` also records tile draws as `"draw"` events.

Check `game_manager.py` — the AI turn loop calls `_append_event(ai_action.type, ...)` where `ai_action.type` could be `"draw"`. But looking at the engine, the tile draw happens internally in `game_session.step()` for active turns — the AI action types are `"discard"`, `"win"`, `"chi"`, `"pong"`, etc. The `"draw"` action type means the player explicitly draws a tile.

The real fix: In `ws_server.py:_send_game_end`, the event uses `phase` as the event name. Change the drawn-game event name from `"draw"` to `"game_draw"` to distinguish it from tile-draw events.

In `ws_server.py:273-283`, change:
```python
event_data: dict = {
    "type": "event",
    "event": "game_end",  # was: phase (which could be "draw")
    "result": phase,       # "win" or "draw"
    "state": manager.get_client_state(reveal_all=True),
}
```

**Step 2: Update frontend handler**

In `useGameSocket.ts:39`, change the condition:
```typescript
if (msg.event === 'game_end') {
```

This ensures only the explicit game-end event triggers the scoring screen transition.

**Step 3: Test manually**

Run: Start a game, discard tiles, verify no flash occurs. Play to completion, verify scoring screen appears correctly on win/draw.

**Step 4: Commit**

```bash
git add backend/server/ws_server.py frontend/src/hooks/useGameSocket.ts
git commit -m "fix: distinguish game-end event from tile-draw to prevent scoring screen flash"
```

---

### Task 3: Wire Animation System into GameView

**Problem:** Animation components exist but `useAnimationQueue` is never called in `GameView`. Events arrive but don't trigger animations.

**Files:**
- Modify: `frontend/src/components/game/GameView.tsx`
- Modify: `frontend/src/hooks/useGameSocket.ts`

**Step 1: Add animation queue to GameView**

In `GameView.tsx`, import and use `useAnimationQueue`:

```tsx
import { useAnimationQueue } from '../../hooks/useAnimationQueue'
import DrawAnimation from '../animations/DrawAnimation'
import DiscardAnimation from '../animations/DiscardAnimation'
import MeldAnimation from '../animations/MeldAnimation'
import WinAnimation from '../animations/WinAnimation'
```

Add to component body:
```tsx
const { currentAnimation, enqueue, completeCurrentAnimation, multiplier } = useAnimationQueue()
```

Render the current animation as an overlay:
```tsx
{currentAnimation && (
  <div className="fixed inset-0 z-40 flex items-center justify-center pointer-events-none">
    {currentAnimation.type === 'draw' && (
      <DrawAnimation
        tile={currentAnimation.data.tile as string}
        onComplete={completeCurrentAnimation}
      />
    )}
    {currentAnimation.type === 'discard' && (
      <DiscardAnimation
        tile={currentAnimation.data.tile as string}
        onComplete={completeCurrentAnimation}
      />
    )}
    {currentAnimation.type === 'meld' && (
      <MeldAnimation
        tiles={currentAnimation.data.tiles as string[]}
        meldType={currentAnimation.data.meldType as string}
        onComplete={completeCurrentAnimation}
      />
    )}
    {currentAnimation.type === 'win' && (
      <WinAnimation
        tiles={currentAnimation.data.tiles as string[]}
        onComplete={completeCurrentAnimation}
      />
    )}
  </div>
)}
```

**Step 2: Enqueue animations from events**

In `useGameSocket.ts`, expose an `onEvent` callback or directly enqueue animations. The cleanest approach: add an `animationQueue` to the store, or pass the enqueue function.

Simpler approach — add a store field `lastEvent` that GameView watches:

In `gameStore.ts`, add:
```typescript
lastEvent: { event: string; player?: number; tile?: string } | null
setLastEvent: (event: ...) => void
```

In `useGameSocket.ts` event handler, after `addEvent(...)`, also call `setLastEvent(...)`.

In `GameView.tsx`, use a `useEffect` that watches `lastEvent` and calls `enqueue()`:
```tsx
const lastEvent = useGameStore((s) => s.lastEvent)

useEffect(() => {
  if (!lastEvent) return
  const { event, tile } = lastEvent
  if (event === 'discard' && tile) {
    enqueue({ id: crypto.randomUUID(), type: 'discard', data: { tile } })
  } else if (event === 'draw' && tile) {
    enqueue({ id: crypto.randomUUID(), type: 'draw', data: { tile } })
  } else if (['chi', 'pong', 'open_kong', 'added_kong', 'concealed_kong'].includes(event)) {
    // For melds, we'd need the tiles — for now skip or use placeholder
  }
  useGameStore.getState().setLastEvent(null)
}, [lastEvent, enqueue])
```

**Step 3: Test manually**

Run: Start a game, observe draw and discard animations playing. Verify animations respect speed settings.

**Step 4: Commit**

```bash
git add frontend/src/components/game/GameView.tsx frontend/src/hooks/useGameSocket.ts frontend/src/store/gameStore.ts
git commit -m "feat: wire animation queue into game view for draw/discard events"
```

---

## Group 2: Interaction Feedback

### Task 4: Add Tile Hover and Click Feedback

**Files:**
- Modify: `frontend/src/components/tiles/TileBase.tsx`
- Modify: `frontend/src/index.css` (add tile hover animation class)

**Step 1: Add hover effect to TileBase**

In `TileBase.tsx`, wrap the SVG in a `<div>` with Tailwind hover classes. The SVG itself can't easily do CSS hover transforms, so wrap it:

Replace the `<svg>` wrapper approach. Instead, add a CSS class in `index.css`:

```css
.tile-interactive {
  transition: transform 150ms ease, filter 150ms ease;
}
.tile-interactive:hover {
  transform: scale(1.08) translateY(-2px);
  filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.3));
}
.tile-interactive:active {
  transform: scale(0.95);
}
```

In `TileBase.tsx`, wrap the SVG in a `<div className="tile-interactive inline-block">` when `onClick` is provided (i.e., it's an interactive tile). Non-interactive tiles (opponent face-down, meld tiles) should not have hover effects.

**Step 2: Test manually**

Run: Hover over tiles in hand, verify scale-up effect. Click tiles, verify press-down feedback.

**Step 3: Commit**

```bash
git add frontend/src/components/tiles/TileBase.tsx frontend/src/index.css
git commit -m "feat: add hover scale-up and click press-down feedback to interactive tiles"
```

---

### Task 5: Add Action Button Feedback

**Files:**
- Modify: `frontend/src/components/game/ActionPanel.tsx`

**Step 1: Enhance button styles**

Add `active:scale-95 transition-all duration-150` to all action buttons. Add a slide-up entrance animation using Framer Motion `AnimatePresence`:

```tsx
import { motion, AnimatePresence } from 'framer-motion'
```

Wrap the panel content in:
```tsx
<AnimatePresence>
  <motion.div
    initial={{ y: 20, opacity: 0 }}
    animate={{ y: 0, opacity: 1 }}
    exit={{ y: 20, opacity: 0 }}
    transition={{ duration: 0.2 }}
    className="flex gap-2"
  >
    {/* buttons */}
  </motion.div>
</AnimatePresence>
```

Add `active:scale-95 transition-transform duration-100` to each button's className.

**Step 2: Commit**

```bash
git add frontend/src/components/game/ActionPanel.tsx
git commit -m "feat: add slide-up entrance animation and press feedback to action buttons"
```

---

### Task 6: Enhance Turn Indicator

**Files:**
- Modify: `frontend/src/components/game/PlayerArea.tsx`
- Modify: `frontend/src/index.css`

**Step 1: Add prominent turn indicator**

Replace the thin `ring-2 ring-yellow-400` with a glowing pulse effect and a "YOUR TURN" badge for the human player.

In `index.css`, add:
```css
@keyframes turn-glow {
  0%, 100% { box-shadow: 0 0 8px 2px rgba(250, 204, 21, 0.4); }
  50% { box-shadow: 0 0 16px 4px rgba(250, 204, 21, 0.7); }
}
.active-turn-glow {
  animation: turn-glow 2s ease-in-out infinite;
  border: 2px solid #facc15;
  border-radius: 0.5rem;
}
```

In `PlayerArea.tsx`, replace the `ring-2 ring-yellow-400` class:
```tsx
<div className={`${positionClasses[position]} ${isActive ? 'active-turn-glow p-1' : 'p-1'}`}>
  {isActive && isSelf && (
    <span className="text-xs font-bold text-yellow-400 animate-pulse mb-1">
      輪到你了！(YOUR TURN)
    </span>
  )}
```

**Step 2: Commit**

```bash
git add frontend/src/components/game/PlayerArea.tsx frontend/src/index.css
git commit -m "feat: add glowing turn indicator with YOUR TURN badge"
```

---

### Task 7: Add Discard Confirmation Hint

**Files:**
- Modify: `frontend/src/components/game/GameView.tsx`

**Step 1: Add hint text when tile is selected**

In `GameView.tsx`, when a tile is selected but no action panel is showing and it's the player's turn, show a hint above the discard button:

Replace the discard button section:
```tsx
{selectedTileCode && !actionRequest && gameState.current_player === myPlayerIndex && (
  <div className="flex flex-col items-center p-2 bg-black/40">
    <span className="text-white/60 text-xs mb-1">再按一次出牌 (Click tile again to discard)</span>
    <button
      onClick={() => {
        onAction('discard', selectedTileCode)
        setSelectedTileIndex(null)
      }}
      className="px-6 py-2 bg-red-600 hover:bg-red-700 active:scale-95 text-white rounded-lg font-bold transition-all duration-150"
    >
      打出 {selectedTileCode} (Discard)
    </button>
  </div>
)}
```

**Step 2: Commit**

```bash
git add frontend/src/components/game/GameView.tsx
git commit -m "feat: add discard confirmation hint text and button press feedback"
```

---

## Group 3: Visual Polish

### Task 8: Polish Table Background

**Files:**
- Modify: `frontend/src/index.css`
- Modify: `frontend/src/components/game/GameView.tsx`

**Step 1: Add radial gradient table background**

In `index.css`, add:
```css
.table-surface {
  background: radial-gradient(ellipse at center, #1f6d35 0%, #1a5c2a 40%, #134a20 100%);
}
```

In `GameView.tsx`, replace `bg-table-green` with `table-surface`:
```tsx
<div className="h-screen table-surface flex flex-col overflow-hidden">
```

**Step 2: Commit**

```bash
git add frontend/src/index.css frontend/src/components/game/GameView.tsx
git commit -m "feat: add radial gradient table background for depth"
```

---

### Task 9: Polish Tile Shadows and 3D Effect

**Files:**
- Modify: `frontend/src/components/tiles/TileBase.tsx`

**Step 1: Improve tile shadow and face rendering**

In `TileBase.tsx`, enhance the shadow and add a subtle top-edge highlight for 3D depth:

Replace the shadow rect:
```tsx
{/* Multi-layer shadow for depth */}
<rect x="2" y="3" width="44" height="60" rx="4" fill="#00000015" />
<rect x="1.5" y="2" width="44" height="60" rx="4" fill="#00000010" />
```

Add a top-edge highlight inside the face-up block (after the face rect):
```tsx
{/* Top-edge highlight for 3D */}
<rect x="1" y="0.5" width="42" height="2" rx="1" fill="#ffffff30" />
```

**Step 2: Commit**

```bash
git add frontend/src/components/tiles/TileBase.tsx
git commit -m "feat: add multi-layer shadow and 3D highlight to tiles"
```

---

### Task 10: Polish Player Areas with Card Backgrounds

**Files:**
- Modify: `frontend/src/components/game/PlayerArea.tsx`

**Step 1: Add semi-transparent card background**

In `PlayerArea.tsx`, add a card-like background to each player area:

Update positionClasses:
```typescript
const positionClasses: Record<string, string> = {
  bottom: 'flex flex-col items-center bg-black/20 rounded-lg backdrop-blur-sm',
  top: 'flex flex-col-reverse items-center bg-black/20 rounded-lg backdrop-blur-sm',
  left: 'flex flex-col items-center bg-black/20 rounded-lg backdrop-blur-sm',
  right: 'flex flex-col items-center bg-black/20 rounded-lg backdrop-blur-sm',
}
```

Update padding to `p-3` for better spacing.

**Step 2: Commit**

```bash
git add frontend/src/components/game/PlayerArea.tsx
git commit -m "feat: add semi-transparent card backgrounds to player areas"
```

---

### Task 11: Polish Discard Pool

**Files:**
- Modify: `frontend/src/components/game/DiscardPool.tsx`

**Step 1: Read current DiscardPool code, then add visual separation**

Add an inset shadow container around the discard pool:
```tsx
<div className="bg-black/15 rounded-lg p-3 shadow-inner">
  {/* existing grid */}
</div>
```

**Step 2: Commit**

```bash
git add frontend/src/components/game/DiscardPool.tsx
git commit -m "feat: add inset shadow container to discard pool"
```

---

### Task 12: Polish Lobby Screen

**Files:**
- Modify: `frontend/src/components/lobby/GameLobby.tsx`
- Modify: `frontend/src/index.css`

**Step 1: Add decorative background and better button styles**

In `index.css`, add a lobby background class:
```css
.lobby-bg {
  background: radial-gradient(ellipse at center, #1f6d35 0%, #14502a 50%, #0d3a1c 100%);
}
```

In `GameLobby.tsx`:
- Replace `bg-table-green` with `lobby-bg`
- Add a decorative border/divider between title and buttons
- Improve button hover effects with `transition-all duration-200 hover:shadow-lg hover:-translate-y-0.5`
- Add `active:scale-95` to all buttons
- Make the connection status indicator more prominent with a dot indicator

**Step 2: Commit**

```bash
git add frontend/src/components/lobby/GameLobby.tsx frontend/src/index.css
git commit -m "feat: polish lobby with gradient background and improved button styles"
```

---

### Task 13: Polish GameHeader Typography

**Files:**
- Modify: `frontend/src/components/game/GameHeader.tsx`

**Step 1: Read current GameHeader, then improve typography**

Increase header font size, add better spacing, and improve the visual hierarchy. Add a subtle bottom border or shadow to separate header from game area.

**Step 2: Commit**

```bash
git add frontend/src/components/game/GameHeader.tsx
git commit -m "feat: improve game header typography and visual separation"
```

---

## Group 4: Final Integration

### Task 14: End-to-End Manual Testing

**Steps:**
1. Start the backend: `cd backend && uv run python -m server`
2. Start the frontend: `cd frontend && pnpm dev`
3. Test each screen: lobby → game → scoring → replay → settings → history
4. Verify:
   - Tile hover/click feedback works
   - Discard does NOT flash scoring screen
   - Animations play on draw/discard
   - Turn indicator is prominent with "YOUR TURN" badge
   - Replay viewer displays game states
   - All visual polish changes look correct
5. Run backend tests: `cd backend && uv run pytest -v`
6. Run frontend tests: `cd frontend && pnpm test`
7. Fix any test failures

### Task 15: Final Commit

```bash
git add -A
git commit -m "feat: Phase 2.5 complete — UI enhancement, bug fixes, visual polish"
```
